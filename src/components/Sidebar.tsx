import { useState, useCallback } from 'react';
import { Upload, Music, Film, X, CheckCircle, Loader2 } from 'lucide-react';
import { selfdb, TABLES, BUCKETS, getTableId, getBucketId } from '../lib/selfdb';
import { generateUUID } from '../lib/uuid';
import logoIcon from '../assets/logo.svg';

interface SidebarProps {
  onMediaAdded?: () => void;
}

export const Sidebar = ({ onMediaAdded }: SidebarProps) => {
  const [isDragging, setIsDragging] = useState(false);
  const [uploads, setUploads] = useState<{
    id: string;
    name: string;
    type: 'audio' | 'video';
    progress: number;
    status: 'uploading' | 'processing' | 'complete' | 'error';
    error?: string;
  }[]>([]);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  }, []);

  const getMediaType = (file: File): 'audio' | 'video' | null => {
    if (file.type.startsWith('audio/')) return 'audio';
    if (file.type.startsWith('video/')) return 'video';
    return null;
  };

  const fileToArrayBuffer = (file: File): Promise<ArrayBuffer> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as ArrayBuffer);
      reader.onerror = reject;
      reader.readAsArrayBuffer(file);
    });
  };

  const extractDuration = (file: File): Promise<number> => {
    return new Promise((resolve) => {
      const url = URL.createObjectURL(file);
      const media = file.type.startsWith('video/') 
        ? document.createElement('video')
        : document.createElement('audio');
      
      media.preload = 'metadata';
      media.onloadedmetadata = () => {
        URL.revokeObjectURL(url);
        resolve(Math.round(media.duration));
      };
      media.onerror = () => {
        URL.revokeObjectURL(url);
        resolve(0);
      };
      media.src = url;
    });
  };

  const generateVideoThumbnail = (file: File): Promise<string | null> => {
    return new Promise((resolve) => {
      if (!file.type.startsWith('video/')) {
        resolve(null);
        return;
      }

      const video = document.createElement('video');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      video.preload = 'metadata';
      video.muted = true;
      video.playsInline = true;

      video.onloadeddata = () => {
        video.currentTime = Math.min(1, video.duration * 0.1);
      };

      video.onseeked = () => {
        canvas.width = 320;
        canvas.height = 180;
        ctx?.drawImage(video, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
        URL.revokeObjectURL(video.src);
        resolve(dataUrl);
      };

      video.onerror = () => {
        URL.revokeObjectURL(video.src);
        resolve(null);
      };

      video.src = URL.createObjectURL(file);
    });
  };

  const uploadFile = async (file: File) => {
    const mediaType = getMediaType(file);
    if (!mediaType) return;

    const uploadId = generateUUID();
    const fileName = file.name.replace(/\.[^/.]+$/, '');

    setUploads(prev => [...prev, {
      id: uploadId,
      name: fileName,
      type: mediaType,
      progress: 0,
      status: 'uploading'
    }]);

    try {
      // Get bucket and table IDs
      const bucketId = await getBucketId(BUCKETS.MEDIA);
      const tableId = await getTableId(TABLES.MEDIA);

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 20 } : u
      ));

      // Convert file to ArrayBuffer
      const fileData = await fileToArrayBuffer(file);

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 40 } : u
      ));

      // Upload file to storage (directly to bucket root)
      const uploadResult = await selfdb.storage.files.upload(bucketId, {
        filename: file.name,
        data: fileData,
        contentType: file.type
      });

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 60, status: 'processing' } : u
      ));

      // Extract metadata
      const duration = await extractDuration(file);
      let cover: string | null = null;

      if (mediaType === 'video') {
        cover = await generateVideoThumbnail(file);
      }

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 80 } : u
      ));

      // Get file path from upload result (just the filename)
      const filePath = uploadResult.path || file.name;

      // Save to database (id is auto-generated by database)
      await selfdb.tables.data.insert(tableId, {
        title: fileName.replace(/[_-]/g, ' '),
        artist: 'Unknown Artist',
        type: mediaType,
        url: filePath,
        cover,
        duration
      });

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 100, status: 'complete' } : u
      ));

      // Remove from list after delay
      setTimeout(() => {
        setUploads(prev => prev.filter(u => u.id !== uploadId));
      }, 2000);

      onMediaAdded?.();

    } catch (error: any) {
      console.error('Upload error:', error);
      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, status: 'error', error: error.message } : u
      ));
    }
  };

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const files = Array.from(e.dataTransfer.files);
    files.forEach(file => {
      if (getMediaType(file)) {
        uploadFile(file);
      }
    });
  }, []);

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    files.forEach(file => {
      if (getMediaType(file)) {
        uploadFile(file);
      }
    });
    e.target.value = '';
  };

  const removeUpload = (id: string) => {
    setUploads(prev => prev.filter(u => u.id !== id));
  };

  return (
    <aside className="w-64 h-full border-r border-border bg-background flex flex-col p-6 hidden md:flex">
      {/* Logo */}
      <div className="flex items-center gap-3 px-2 mb-8">
        <img src={logoIcon} alt="StreamX" className="w-10 h-10 shadow-accent" />
        <h1 className="text-2xl font-bold tracking-tight gradient-text">StreamX</h1>
      </div>

      {/* Drop Zone */}
      <div
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        className={`
          flex-1 flex flex-col items-center justify-center
          border-2 border-dashed rounded-2xl p-6 transition-all duration-300 cursor-pointer
          ${isDragging 
            ? 'border-accent bg-accent-subtle scale-[1.02]' 
            : 'border-border hover:border-accent/50 hover:bg-accent-subtle'
          }
        `}
        onClick={() => document.getElementById('file-input')?.click()}
      >
        <input
          id="file-input"
          type="file"
          multiple
          accept="audio/*,video/*"
          onChange={handleFileSelect}
          className="hidden"
        />

        <div className={`
          w-16 h-16 rounded-2xl flex items-center justify-center mb-4 transition-all duration-300
          ${isDragging ? 'bg-accent/20 scale-110' : 'bg-accent-subtle'}
        `}>
          <Upload className={`w-8 h-8 transition-colors ${isDragging ? 'text-accent' : 'text-foreground-subtle'}`} />
        </div>

        <p className={`text-sm font-medium text-center mb-2 transition-colors ${isDragging ? 'text-accent' : 'text-foreground'}`}>
          {isDragging ? 'Drop files here' : 'Drag & drop media'}
        </p>
        <p className="text-xs text-foreground-subtle text-center">
          or click to browse
        </p>

        <div className="flex items-center gap-3 mt-4 text-xs text-foreground-subtle">
          <div className="flex items-center gap-1">
            <Music className="w-3 h-3" />
            <span>Audio</span>
          </div>
          <span>â€¢</span>
          <div className="flex items-center gap-1">
            <Film className="w-3 h-3" />
            <span>Video</span>
          </div>
        </div>
      </div>

      {/* Upload Progress */}
      {uploads.length > 0 && (
        <div className="mt-4 space-y-2 max-h-48 overflow-y-auto custom-scrollbar">
          {uploads.map(upload => (
            <div 
              key={upload.id}
              className="bg-surface rounded-xl p-3 border border-border shadow-soft"
            >
              <div className="flex items-center gap-2 mb-2">
                {upload.type === 'audio' ? (
                  <Music className="w-4 h-4 text-accent flex-shrink-0" />
                ) : (
                  <Film className="w-4 h-4 text-secondary flex-shrink-0" />
                )}
                <span className="text-xs text-foreground truncate flex-1">{upload.name}</span>
                
                {upload.status === 'complete' && (
                  <CheckCircle className="w-4 h-4 text-success flex-shrink-0" />
                )}
                {upload.status === 'error' && (
                  <button onClick={() => removeUpload(upload.id)}>
                    <X className="w-4 h-4 text-error flex-shrink-0" />
                  </button>
                )}
                {(upload.status === 'uploading' || upload.status === 'processing') && (
                  <Loader2 className="w-4 h-4 text-accent animate-spin flex-shrink-0" />
                )}
              </div>

              {upload.status !== 'error' && (
                <div className="h-1 bg-border rounded-full overflow-hidden">
                  <div 
                    className={`h-full rounded-full transition-all duration-300 ${
                      upload.status === 'complete' ? 'bg-success' : 'bg-accent'
                    }`}
                    style={{ width: `${upload.progress}%` }}
                  />
                </div>
              )}

              {upload.status === 'processing' && (
                <p className="text-[10px] text-foreground-subtle mt-1">Processing metadata...</p>
              )}

              {upload.status === 'error' && (
                <p className="text-[10px] text-error mt-1">{upload.error}</p>
              )}
            </div>
          ))}
        </div>
      )}

      {/* Footer hint */}
      <div className="mt-4 pt-4 border-t border-border">
        <p className="text-[10px] text-foreground-subtle text-center">
          Supported: MP3, WAV, FLAC, MP4, WebM, MKV
        </p>
      </div>
    </aside>
  );
};







