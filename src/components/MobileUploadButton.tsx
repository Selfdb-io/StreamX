import { useState, useCallback } from 'react';
import { Plus, X, Music, Film, CheckCircle, Loader2, Upload } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { selfdb, TABLES, BUCKETS, getTableId, getBucketId } from '../lib/selfdb';
import { generateUUID } from '../lib/uuid';

interface MobileUploadButtonProps {
  onMediaAdded?: () => void;
  hasAudioPlayer?: boolean;
}

interface UploadItem {
  id: string;
  name: string;
  type: 'audio' | 'video';
  progress: number;
  status: 'uploading' | 'processing' | 'complete' | 'error';
  error?: string;
}

export const MobileUploadButton = ({ onMediaAdded, hasAudioPlayer = false }: MobileUploadButtonProps) => {
  const [uploads, setUploads] = useState<UploadItem[]>([]);
  const [showToast, setShowToast] = useState(false);

  const getMediaType = (file: File): 'audio' | 'video' | null => {
    if (file.type.startsWith('audio/')) return 'audio';
    if (file.type.startsWith('video/')) return 'video';
    return null;
  };

  const fileToArrayBuffer = (file: File): Promise<ArrayBuffer> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as ArrayBuffer);
      reader.onerror = reject;
      reader.readAsArrayBuffer(file);
    });
  };

  const extractDuration = (file: File): Promise<number> => {
    return new Promise((resolve) => {
      const url = URL.createObjectURL(file);
      const media = file.type.startsWith('video/') 
        ? document.createElement('video')
        : document.createElement('audio');
      
      media.preload = 'metadata';
      media.onloadedmetadata = () => {
        URL.revokeObjectURL(url);
        resolve(Math.round(media.duration));
      };
      media.onerror = () => {
        URL.revokeObjectURL(url);
        resolve(0);
      };
      media.src = url;
    });
  };

  const generateVideoThumbnail = (file: File): Promise<string | null> => {
    return new Promise((resolve) => {
      if (!file.type.startsWith('video/')) {
        resolve(null);
        return;
      }

      const video = document.createElement('video');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      video.preload = 'metadata';
      video.muted = true;
      video.playsInline = true;

      video.onloadeddata = () => {
        video.currentTime = Math.min(1, video.duration * 0.1);
      };

      video.onseeked = () => {
        canvas.width = 320;
        canvas.height = 180;
        ctx?.drawImage(video, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
        URL.revokeObjectURL(video.src);
        resolve(dataUrl);
      };

      video.onerror = () => {
        URL.revokeObjectURL(video.src);
        resolve(null);
      };

      video.src = URL.createObjectURL(file);
    });
  };

  const uploadFile = async (file: File) => {
    const mediaType = getMediaType(file);
    if (!mediaType) return;

    const uploadId = generateUUID();
    const fileName = file.name.replace(/\.[^/.]+$/, '');

    setUploads(prev => [...prev, {
      id: uploadId,
      name: fileName,
      type: mediaType,
      progress: 0,
      status: 'uploading'
    }]);
    setShowToast(true);

    try {
      const bucketId = await getBucketId(BUCKETS.MEDIA);
      const tableId = await getTableId(TABLES.MEDIA);

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 20 } : u
      ));

      const fileData = await fileToArrayBuffer(file);

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 40 } : u
      ));

      // Upload file to storage (directly to bucket root)
      const uploadResult = await selfdb.storage.files.upload(bucketId, {
        filename: file.name,
        data: fileData,
        contentType: file.type
      });

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 60, status: 'processing' } : u
      ));

      const duration = await extractDuration(file);
      let cover: string | null = null;

      if (mediaType === 'video') {
        cover = await generateVideoThumbnail(file);
      }

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 80 } : u
      ));

      // Get file path from upload result (just the filename)
      const filePath = uploadResult.path || file.name;

      // Save to database (id is auto-generated by database)
      await selfdb.tables.data.insert(tableId, {
        title: fileName.replace(/[_-]/g, ' '),
        artist: 'Unknown Artist',
        type: mediaType,
        url: filePath,
        cover,
        duration
      });

      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, progress: 100, status: 'complete' } : u
      ));

      setTimeout(() => {
        setUploads(prev => {
          const filtered = prev.filter(u => u.id !== uploadId);
          if (filtered.length === 0) setShowToast(false);
          return filtered;
        });
      }, 2000);

      onMediaAdded?.();

    } catch (error: any) {
      console.error('Upload error:', error);
      setUploads(prev => prev.map(u => 
        u.id === uploadId ? { ...u, status: 'error', error: error.message } : u
      ));
    }
  };

  const handleFileSelect = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    files.forEach(file => {
      if (getMediaType(file)) {
        uploadFile(file);
      }
    });
    e.target.value = '';
  }, []);

  const removeUpload = (id: string) => {
    setUploads(prev => {
      const filtered = prev.filter(u => u.id !== id);
      if (filtered.length === 0) setShowToast(false);
      return filtered;
    });
  };

  const activeUploads = uploads.filter(u => u.status !== 'complete');
  const hasActiveUploads = activeUploads.length > 0;

  return (
    <>
      {/* Floating Action Button - Mobile Only */}
      <div 
        className="fixed right-4 z-[55] md:hidden transition-all duration-300"
        style={{ bottom: hasAudioPlayer ? 'calc(11rem + env(safe-area-inset-bottom, 0px))' : '1.5rem' }}
      >
        <input
          id="mobile-file-input"
          type="file"
          multiple
          accept="audio/*,video/*"
          onChange={handleFileSelect}
          className="hidden"
        />
        
        <motion.button
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          onClick={() => document.getElementById('mobile-file-input')?.click()}
          className={`w-14 h-14 rounded-full shadow-accent flex items-center justify-center transition-all ${
            hasActiveUploads 
              ? 'bg-accent shadow-glow' 
              : 'bg-gradient-to-br from-accent to-accent-hover shadow-glow'
          }`}
        >
          {hasActiveUploads ? (
            <Loader2 className="w-6 h-6 text-foreground-inverted animate-spin" />
          ) : (
            <Plus className="w-7 h-7 text-foreground-inverted" />
          )}
        </motion.button>
      </div>

      {/* Upload Progress Toast */}
      <AnimatePresence>
        {showToast && uploads.length > 0 && (
          <motion.div
            initial={{ y: 100, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            exit={{ y: 100, opacity: 0 }}
            className="fixed left-4 right-4 z-[55] md:hidden"
            style={{ bottom: hasAudioPlayer ? 'calc(15rem + env(safe-area-inset-bottom, 0px))' : '6rem' }}
          >
            <div className="bg-foreground border border-foreground-inverted/10 rounded-2xl p-4 shadow-elevated">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-2">
                  <Upload className="w-4 h-4 text-accent-light" />
                  <span className="text-sm font-medium text-foreground-inverted">
                    {hasActiveUploads ? 'Uploading...' : 'Upload Complete'}
                  </span>
                </div>
                <button 
                  onClick={() => setShowToast(false)}
                  className="p-1 text-foreground-inverted/50 hover:text-foreground-inverted"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>

              <div className="space-y-2 max-h-32 overflow-y-auto">
                {uploads.map(upload => (
                  <div key={upload.id} className="flex items-center gap-3">
                    {upload.type === 'audio' ? (
                      <Music className="w-4 h-4 text-accent-light flex-shrink-0" />
                    ) : (
                      <Film className="w-4 h-4 text-secondary flex-shrink-0" />
                    )}
                    
                    <div className="flex-1 min-w-0">
                      <p className="text-xs text-foreground-inverted truncate">{upload.name}</p>
                      {upload.status !== 'error' && (
                        <div className="h-1 bg-foreground-inverted/10 rounded-full overflow-hidden mt-1">
                          <div 
                            className={`h-full rounded-full transition-all duration-300 ${
                              upload.status === 'complete' ? 'bg-success' : 'bg-accent'
                            }`}
                            style={{ width: `${upload.progress}%` }}
                          />
                        </div>
                      )}
                      {upload.status === 'error' && (
                        <p className="text-[10px] text-error mt-0.5">{upload.error}</p>
                      )}
                    </div>

                    {upload.status === 'complete' && (
                      <CheckCircle className="w-4 h-4 text-success flex-shrink-0" />
                    )}
                    {upload.status === 'error' && (
                      <button onClick={() => removeUpload(upload.id)}>
                        <X className="w-4 h-4 text-error flex-shrink-0" />
                      </button>
                    )}
                  </div>
                ))}
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
};
